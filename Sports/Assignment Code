"""
Sports Analytics
"""

import numeric
import codeskulptor

import comp140_module6 as sports
from urllib import request

def read_matrix(filename):
    """
    Parse data from the file with the given filename into a matrix.

    input:
        - filename: a string representing the name of the file

    returns: a matrix containing the elements in the given file
    """
    file = request.urlopen(codeskulptor.file2url(filename))  
    file = file.readlines()  
    values = []
    for line in range(len(file)):  # Iterate through each line
        temp = (str(file[line])[2:len(str(file[line]))-3].split(", "))  # Clean and split line
        temp2 = []
        for column in temp:  # Process each column entry
            if column.find("\\r") == -1:  # Extra case for very few lines in file
                temp2.append(float(column))  
            else:
                temp2.append(float(column[0:column.find('\\r')]))  # Remove extra string
        values.append(temp2)  
    return numeric.Matrix(values)  # Return matrix object



class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.

        inputs:
            - weights: an m x 1 matrix of weights
        """
        self._weights = weights  # Store weight matrix

    def __str__(self):
        """
        Return: weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return: the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.

        inputs:
            - inputs: an n x m matrix of explanatory variables

        Returns: an n x 1 matrix of predictions
        """
        return inputs @ self.get_weights()  # Matrix multiplication for predictions

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.
        """
        predictions = self.generate_predictions(inputs)  # Compute predictions
        sum_square = 0  # Accumulate squared errors

        for row in range(actual_result.shape()[0]):  # Iterate over rows
            difference = (actual_result[(row, 0)] - predictions[(row, 0)]) ** 2  # Squared error
            sum_square += difference  

        return sum_square / actual_result.shape()[0]  # Mean squared error




def fit_least_squares(input_data, output_data):
    """
    Fit a Linear Model using the Least Squares method.
    """
    if output_data.abs().summation() == 0:  # Special case: all-zero output
        return LinearModel(input_data.transpose() @ output_data)
    else:
        x_transpose = input_data.transpose()  # Compute X^T
        product = x_transpose @ input_data  # Compute X^T X
        inverse = product.inverse()  # Compute (X^T X)^(-1)
        product2 = x_transpose @ output_data  # Compute X^T y
        weights = inverse @ product2  # Compute weights
        return LinearModel(weights)

def soft_threshold(parameterx, parametert):
    """
    Soft-thresholding operator: moves x toward 0 by amount t.
    """
    value = 0
    if parameterx > parametert:  # Positive side threshold
        value = parameterx - parametert
    elif abs(parameterx) <= parametert:  # Inside threshold zone
        value = 0
    elif parameterx < (parametert * -1):  # Negative side threshold
        value = parameterx + parametert
    return value

def fit_lasso(param, iterations, input_data, output_data):
    """
    Fit a Linear Model using LASSO regression.
    """
    weights = fit_least_squares(input_data, output_data).get_weights() # Initialize with LS solution
    counter = 0
    while counter < iterations:  # Loop for coordinate descent
        weight1 = weights.copy()  # Keep previous weights for convergence check
        for index in range(input_data.shape()[1]):  # Loop over each feature
            
            matrix1 = input_data.transpose() @ output_data  # X^T y
            matrix2 = input_data.transpose() @ input_data  # X^T X
            row = matrix2.getrow(index)  # Extract j-th row of X^T X
            matrix3 = row @ weights  # Compute contribution of all weights
            difference = matrix1[(index, 0)] - matrix3[(0, 0)]  # Residual contribution

            # aj and bj in coordinate descent formula
            a_quantity = difference / matrix2[(index, index)]
            b_quantity = param / (2 * matrix2[(index, index)])

            weights[(index, 0)]=soft_threshold(weights[(index, 0)]+a_quantity,b_quantity)

        if (weights - weight1).abs().summation() < 10 ** (-5):  # Convergence check
            return LinearModel(weights)
        counter += 1
    return LinearModel(weights)

def run_experiment(iterations):
    """
    Train LASSO and LS models on historical baseball data and
    print prediction errors.
    """

    matrix1 = read_matrix("comp140_analytics_baseball.txt")  # Training inputs
    actual_result1 = read_matrix("comp140_analytics_wins.txt")  # Training targets
    
    ls_model = fit_least_squares(matrix1, actual_result1)
    
    fit_model_1=fit_lasso(1000, iterations, matrix1, actual_result1)
    fit_model_2=fit_lasso(10000, iterations, matrix1, actual_result1)
    fit_model_3=fit_lasso(100000, iterations, matrix1, actual_result1)
    
    fit_train_1=fit_model_1.prediction_error(matrix1, actual_result1)
    fit_train_2=fit_model_2.prediction_error(matrix1, actual_result1)
    fit_train_3=fit_model_3.prediction_error(matrix1, actual_result1)
    ls_error_train=ls_model.prediction_error(matrix1, actual_result1)
    
    print(f"1954-2000 Lasso Fit Model:{fit_train_1},{fit_train_2},{fit_train_3}")
    print(f"1954-2000 LS Model:{ls_error_train}")
    matrix2 = read_matrix("comp140_analytics_baseball_test.txt")
    actual_result2 = read_matrix("comp140_analytics_wins_test.txt")
    ls_error_test=ls_model.prediction_error(matrix2, actual_result2)
    
    fit_test_1=fit_model_1.prediction_error(matrix2, actual_result2)
    fit_test_2=fit_model_2.prediction_error(matrix2, actual_result2)
    fit_test_3=fit_model_3.prediction_error(matrix2, actual_result2)
    print(f"2001-2012 Lasso Fit Model:{fit_test_1},{fit_test_2},{fit_test_3}")
    print(f"2001-2012 LS Model:{ls_error_test}")
    
run_experiment(1)
